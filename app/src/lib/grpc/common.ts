// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';

export const protobufPackage = 'common';

export interface Selector {
	domain?: string | undefined;
	id: bigint;
}

function createBaseSelector(): Selector {
	return { domain: undefined, id: 0n };
}

export const Selector: MessageFns<Selector> = {
	encode(message: Selector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.domain !== undefined) {
			writer.uint32(10).string(message.domain);
		}
		if (message.id !== 0n) {
			if (BigInt.asUintN(64, message.id) !== message.id) {
				throw new gt.Error('value provided for field message.id of type fixed64 too large');
			}
			writer.uint32(17).fixed64(message.id);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Selector {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSelector();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.domain = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 17) {
						break;
					}

					message.id = reader.fixed64() as bigint;
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Selector {
		return {
			domain: isSet(object.domain) ? gt.String(object.domain) : undefined,
			id: isSet(object.id) ? BigInt(object.id) : 0n
		};
	},

	toJSON(message: Selector): unknown {
		const obj: any = {};
		if (message.domain !== undefined) {
			obj.domain = message.domain;
		}
		if (message.id !== 0n) {
			obj.id = message.id.toString();
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Selector>, I>>(base?: I): Selector {
		return Selector.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Selector>, I>>(object: I): Selector {
		const message = createBaseSelector();
		message.domain = object.domain ?? undefined;
		message.id = object.id ?? 0n;
		return message;
	}
};

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
	if (typeof globalThis !== 'undefined') {
		return globalThis;
	}
	if (typeof self !== 'undefined') {
		return self;
	}
	if (typeof window !== 'undefined') {
		return window;
	}
	if (typeof global !== 'undefined') {
		return global;
	}
	throw 'Unable to locate global object';
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends { $case: string; value: unknown }
				? { $case: T['$case']; value?: DeepPartial<T['value']> }
				: T extends {}
					? { [K in keyof T]?: DeepPartial<T[K]> }
					: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

export interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
